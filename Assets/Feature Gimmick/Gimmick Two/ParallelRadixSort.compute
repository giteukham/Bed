//////////////////////////////////////
///	DO NOT USE KOREAN IN THIS FILE ///
//////////////////////////////////////

#pragma kernel RadixSort
#pragma kernel LocalMaskScan

#define THREAD_SIZE 256

StructuredBuffer<uint> _blockSumsScanBuffer;
RWStructuredBuffer<uint> _unsortedBuffer;
RWStructuredBuffer<uint> _localMaskScanBuffer;
RWStructuredBuffer<uint> _blockSumsBuffer;
RWStructuredBuffer<uint> _sortedBufferByRadix;

uint _elementCount;
int _blockSumGroupCount;
int _bitShift;

groupshared uint _tempInput[THREAD_SIZE];
groupshared uint _localMask[THREAD_SIZE];

[numthreads(THREAD_SIZE, 1, 1)]
void LocalMaskScan(uint3 tid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	if (tid.x <= _elementCount)
	{
		_tempInput[tid.x] = _unsortedBuffer[tid.x];
	}
	else
	{
		_tempInput[tid.x] = 0;
	}
	GroupMemoryBarrierWithGroupSync();
	
	const uint extract2bit = (_tempInput[tid.x] >> _bitShift) & 0x3;
	GroupMemoryBarrierWithGroupSync();
	
	for (int i = 0; i < 4; i++)
	{
		const bool isMask = extract2bit == i;

		_localMask[gtid.x] = (uint)isMask;
		GroupMemoryBarrierWithGroupSync();
		
		//Exclusive Prefix Sum
		for (int offset = 1; offset < THREAD_SIZE; offset <<= 1)
		{
			if (tid.x >= offset)
			{
				_localMask[gtid.x] += _localMask[gtid.x - offset];
			}
			else
			{
				_localMask[gtid.x] = _localMask[gtid.x];
			}
			GroupMemoryBarrierWithGroupSync();
		}

		if (gtid.x == 0)
		{
			_localMask[tid.x] = 0;
		}
		GroupMemoryBarrierWithGroupSync();

		_localMask[gtid.x] = _localMask[gtid.x - 1];
		GroupMemoryBarrierWithGroupSync();
		
		if (tid.x < _elementCount)
		{
			_blockSumsBuffer[i * _blockSumGroupCount + gid.x] = _localMask[_elementCount - 1];
		}
		else
		{
			_blockSumsBuffer[i * _blockSumGroupCount + gid.x] = 0;
		}
		GroupMemoryBarrierWithGroupSync();

		if (_bitShift == 0)
		{
			_sortedBufferByRadix[tid.x] = _blockSumsBuffer[tid.x];
		}
	}
}

[numthreads(THREAD_SIZE, 1, 1)]
void RadixSort(uint3 tid : SV_DispatchThreadID)
{
	const uint extract2bit = (_unsortedBuffer[tid.x] >> _bitShift) & 0x3;
	const uint prefixSum = _localMaskScanBuffer[tid.x];
	const uint pos = _blockSumsScanBuffer[extract2bit * _blockSumGroupCount] + prefixSum;
	GroupMemoryBarrierWithGroupSync();
	
	if (tid.x < _elementCount)
	{
		_sortedBufferByRadix[pos] = _unsortedBuffer[tid.x];
	}
	GroupMemoryBarrierWithGroupSync();

	_unsortedBuffer[tid.x] = _sortedBufferByRadix[tid.x];
	GroupMemoryBarrierWithGroupSync();
}

