//////////////////////////////////////
///	DO NOT USE KOREAN IN THIS FILE ///
//////////////////////////////////////

#pragma kernel InsertParticlesInCell
#pragma kernel UpdateCellStartEnds
#pragma kernel NeighborSearch
#pragma kernel CalculateDensityAndPressures
#pragma kernel CalculateForces
#pragma kernel Integrate

#define THREAD_SIZE 256

#define GRAVITY 9.81
#define NEIGHBOR_COUNT 27
#define DELTA_TIME 0.016f
#define NUMERIC_LIMIT 0xFFFFFFFF

#include "SpatialHash.hlsl"
#include "ParticleUtils.hlsl"

struct Particle
{
	float3 position;
	float4 color;
};

struct CellInfo
{
	int particleIndex;
	int hash;
};

RWStructuredBuffer<Particle> _particles;
RWStructuredBuffer<float3> _velocities;
RWStructuredBuffer<float> _densities;
RWStructuredBuffer<float> _pressures;
RWStructuredBuffer<float3> _forces;

RWStructuredBuffer<CellInfo> _cellIndices;
RWStructuredBuffer<uint> _cellStarts, _cellEnds;
RWStructuredBuffer<uint> _neighbors;

RWStructuredBuffer<float3> _test;

float3 _boundingBox;
float3 _boundMin, _boundMax;
float _particleRadius;
float _cellSize;
float _damping;
float _smoothingLength;

float _mass;
float _restDensity;
float _viscosity;
float _gasConstant;

uint _particleCount;
uint _totalCellNumbers;

groupshared Particle _groupParticles[THREAD_SIZE];

[numthreads(THREAD_SIZE, 1, 1)]
void InsertParticlesInCell(uint3 tid : SV_DispatchThreadID)
{
	uint threadId = tid.x;
	
	if (threadId < _particleCount)
	{
		int3 gridPos = CalculateGridPosition( _particles[threadId].position, _cellSize);
		uint hash = HashFunction(gridPos, _totalCellNumbers);

		_cellIndices[threadId].particleIndex = threadId;
		_cellIndices[threadId].hash = hash;
	}
}

// Reference : https://medium.com/@ahmed.fathy.elbossily/sph-and-hashing-c28e70ff7615
[numthreads(THREAD_SIZE, 1, 1)]
void UpdateCellStartEnds(uint3 tid : SV_DispatchThreadID)
{
	uint threadId = tid.x;

	uint currentHash = _cellIndices[threadId].hash;
	uint previousHash = threadId > 0 ? _cellIndices[threadId - 1].hash : NUMERIC_LIMIT;

	if (threadId == 0 || currentHash != previousHash)
	{
		_cellStarts[currentHash] = threadId;
	}

	if (threadId == _particleCount - 1 || currentHash != _cellIndices[threadId + 1].hash)
	{
		_cellEnds[currentHash] = threadId;
	}

	_test[threadId] = float3(_cellIndices[threadId].particleIndex, _cellIndices[threadId].hash, _cellStarts[_cellIndices[threadId].hash]);
	//
	//
	// if (threadId > 0 && threadId < _particleCount)
	// {
	// 	// uint hash = _cellIndices[threadId].hash;
	// 	//
	// 	// if (hash != _cellIndices[threadId + 1].hash)
	// 	// {
	// 	// 	_cellEnds[hash] = threadId;
	// 	// 	_cellStarts[_cellIndices[threadId + 1].hash] = threadId + 1;
	// 	// }
	// }
	//
	// _cellEnds[firstHash] = _particleCount - 1;
}

[numthreads(THREAD_SIZE, 1, 1)]
void NeighborSearch(uint3 tid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	uint threadId = tid.x;
	float3 originPos = _particles[threadId].position;
	int3 gridPos = CalculateGridPosition(originPos, _cellSize);
	uint hash = HashFunction(gridPos, _totalCellNumbers);

	uint neighborCount = 0;
	uint test = 0;
	for (int i = -1; i <= 1; ++i)
	for (int j = -1; j <= 1; ++j)
	for (int k = -1; k <= 1; ++k)
	{
		int3 neighborGridPos = gridPos + int3(i, j, k);
		uint neighborHash = HashFunction(neighborGridPos, _totalCellNumbers);

		if (threadId < _particleCount && hash != neighborHash)
		{
			uint start = _cellStarts[neighborHash];
			uint end = _cellEnds[neighborHash];
			
			for (uint idx = start; idx <= end; idx++)
			{
				float3 neighborPos = _particles[_cellIndices[idx].particleIndex].position;
				float dist = length(neighborPos - originPos);
				if (dist < _cellSize * 2)
				{
					_neighbors[threadId * NEIGHBOR_COUNT + neighborCount] = _cellIndices[idx].particleIndex;
					neighborCount++;
					
				}
			}
		}
		test++;

		GroupMemoryBarrierWithGroupSync();
	}
}

[numthreads(THREAD_SIZE, 1, 1)]
void CalculateDensityAndPressures(uint3 tid : SV_DispatchThreadID, uint gidx : SV_GroupIndex)
{
	if (tid.x >= _particleCount) return;
	
	uint threadId = tid.x;
	Particle particle = _particles[threadId];
	uint numTiles = 1 + _particleCount / THREAD_SIZE;
	
	int3 gridPos = CalculateGridPosition(particle.position, _cellSize);
	uint hash = HashFunction(gridPos, _totalCellNumbers);

	float rho = 0.0;
	
	// for (int tile = 0; tile < numTiles; ++tile)
	// {
	// 	uint offset = tile * THREAD_SIZE;
	// 	_groupParticles[gidx] = _particles[offset + gidx];
	// 	GroupMemoryBarrierWithGroupSync();
		for (int i = 0; i < NEIGHBOR_COUNT; i++)
		{
			uint neighborId = _neighbors[threadId * NEIGHBOR_COUNT + i];
			Particle neighbor = _particles[neighborId];

			if (neighborId == NUMERIC_LIMIT || neighborId == threadId) continue;

			float3 diff = particle.position - neighbor.position;
			float r2 = dot(diff, diff);
			float r = sqrt(r2);
			float h = _smoothingLength;
			
			if (r < h)
			{
				float poly6 = Poly6Kernel(h, r);
				rho += poly6;
			}
		}
	//}
	_densities[threadId] = rho * _mass + 0.001f;
	_densities[threadId] = max(_densities[threadId], _restDensity);
	_pressures[threadId] = _gasConstant * (_densities[threadId] - _restDensity);


}

[numthreads(THREAD_SIZE, 1, 1)]
void CalculateForces(uint3 tid : SV_DispatchThreadID, uint gidx : SV_GroupIndex)
{
	if (tid.x >= _particleCount) return;
	
	uint threadId = tid.x;
	Particle particle = _particles[threadId];
	uint numTiles = 1 + _particleCount / THREAD_SIZE;
	
	int3 gridPos = CalculateGridPosition(particle.position, _cellSize);
	uint hash = HashFunction(gridPos, _totalCellNumbers);
		
	_forces[threadId] = float3(0, 0, 0);
	// for (int tile = 0; tile < numTiles; ++tile)
	// {
	// 	uint offset = tile * THREAD_SIZE;
	// 	_groupParticles[gidx] = _particles[offset + gidx];
	// 	GroupMemoryBarrierWithGroupSync();

		for (int i = 0; i < NEIGHBOR_COUNT - 1; i++)
		{
			uint neighborId = _neighbors[threadId * NEIGHBOR_COUNT + i];
			Particle neighbor = _particles[neighborId];

			if (neighborId == NUMERIC_LIMIT || neighborId == threadId) continue;
			
			float3 diff = particle.position - neighbor.position;
			float r2 = dot(diff, diff);
			float r = sqrt(r2);
			float h = _smoothingLength;
		
			if (r > 0.0 && r < h)
			{
				float spiky = DerivativeSpikyKernel(h, r);
				float vis = ViscosityKernel(h, r);
				float3 dir = diff / r;
				_forces[threadId] -= _mass * (_pressures[threadId] + _pressures[neighborId]) / (2 * _densities[neighborId]) * spiky * dir;
				_forces[threadId] += _mass * (_velocities[neighborId] - _velocities[threadId]) / _densities[neighborId] * vis * dir;

			}
		}
	//}
	_forces[threadId] *= _viscosity;
}

[numthreads(THREAD_SIZE, 1, 1)]
void Integrate (uint3 tid : SV_DispatchThreadID)
{
	uint threadId = tid.x;
	const float deltaTime = DELTA_TIME;
	const float3 gravity = float3(0, -GRAVITY, 0);
	
	_velocities[threadId] += deltaTime * (_forces[threadId] / _densities[threadId] + gravity);
	_particles[threadId].position += deltaTime * _velocities[threadId];

	Particle particle = _particles[threadId];
	float3 vel = _velocities[threadId];
	
	if (particle.position.x < _boundMin.x + _particleRadius)
	{
		vel.x *= _damping;
		particle.position.x = _boundMin.x + _particleRadius;
	}
	else if (particle.position.x > _boundMax.x - _particleRadius)
	{
		vel.x *= _damping;
		particle.position.x = _boundMax.x - _particleRadius;
	}
	
	if (particle.position.y < _boundMin.y + _particleRadius)
	{
		vel.y *= _damping;
		particle.position.y = _boundMin.y + _particleRadius;
	}
	else if (particle.position.y > _boundMax.y - _particleRadius)
	{
		vel.y *= _damping;
		particle.position.y = _boundMax.y - _particleRadius;
	}

	if (particle.position.z < _boundMin.z + _particleRadius)
	{
		vel.z *= _damping;
		particle.position.z = _boundMin.z + _particleRadius;
	}
	else if (particle.position.z > _boundMax.z - _particleRadius)
	{
		vel.z *= _damping;
		particle.position.z = _boundMax.z - _particleRadius;
	}

	_particles[threadId] = particle;
	_velocities[threadId] = vel;
}