//////////////////////////////////////
///	DO NOT USE KOREAN IN THIS FILE ///
//////////////////////////////////////

#pragma kernel InsertParticlesInCell
#pragma kernel InsertCellStartByCellId
#pragma kernel NeighborSearch
#pragma kernel CalculateDensityAndPressures
#pragma kernel CalculateForces
#pragma kernel Integrate

#define THREAD_SIZE 256
#define TABLE_SIZE 200000

#define GRAVITY 9.81
#define NEIGHBOR_COUNT 8
#define DELTA_TIME 0.016f

#include "SpatialHash.hlsl"
#include "ParticleUtils.hlsl"

struct Particle
{
	float3 position;
	float4 color;
};

RWStructuredBuffer<Particle> _particles;
RWStructuredBuffer<float3> _viscosities;
RWStructuredBuffer<float3> _velocities;
RWStructuredBuffer<float> _densities;
RWStructuredBuffer<float> _pressures;
RWStructuredBuffer<float3> _forces;

RWStructuredBuffer<uint2> _cellLists;					// x is the cell index, y is the particle index
RWStructuredBuffer<uint> _cellStartIndices;
RWStructuredBuffer<uint> _neighbors;

RWStructuredBuffer<float3> _test;

float3 _boundingBox;
float _particleRadius;
float _cellSize;
uint _cellNumbers;
float _damping;

float _mass;
float _restDensity;
float _viscosity;
float _gasConstant;

uint _particleCount;

groupshared Particle _groupParticles[THREAD_SIZE];

[numthreads(THREAD_SIZE, 1, 1)]
void InsertParticlesInCell(uint3 tid : SV_DispatchThreadID)
{
	uint threadId = tid.x;
	
	if (threadId < _particleCount)
	{
		Particle particle = _particles[threadId];
		int3 gridPos = CalculateGridPosition(particle.position, _cellSize);
		uint hash = HashFunction(gridPos);

		_test[threadId] = hash;
	}
}

[numthreads(THREAD_SIZE, 1, 1)]
void InsertCellStartByCellId(uint3 tid : SV_DispatchThreadID)
{
	uint threadId = tid.x;
	uint cellId = _cellLists[threadId].x;
	
	_cellStartIndices[threadId] = 0xFFFFFFFF;
	GroupMemoryBarrierWithGroupSync();
	
	InterlockedMin(_cellStartIndices[cellId], threadId);
}

[numthreads(THREAD_SIZE, 1, 1)]
void NeighborSearch(uint3 tid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	uint threadId = tid.x;
	Particle particle = _particles[threadId];
	int3 cellDimIndex = CalculateGridPosition(particle.position, _particleRadius);
	uint cellIndex = HashFunction(cellDimIndex, TABLE_SIZE);

	int neighborCount = 0;
	uint test = 0;
	for (int i = -1; i <= 1; ++i)
	for (int j = -1; j <= 1; ++j)
	for (int k = -1; k <= 1; ++k)
	{
		int3 neighborCellDimIndex = cellDimIndex + int3(i, j, k);
		uint neighborCellIndex = HashFunction(neighborCellDimIndex, TABLE_SIZE);
		test++;

		uint start = _cellStartIndices[neighborCellIndex];
		GroupMemoryBarrierWithGroupSync();
		
		if (start == 0xFFFFFFFF)
		{
			continue;
		}

		while (start < _particleCount)
		{
			if (cellIndex == threadId)
			{
				cellIndex++;
				continue;
			}
			uint neighborParticleId = _cellLists[start].y;
			if (_cellLists[neighborParticleId].x != neighborCellIndex)
			{
				break;
			}
			float dist = length(particle.position - _particles[neighborParticleId].position);
			if (dot(dist, dist) < pow(_particleRadius, 2))
			{
				_neighbors[cellIndex * NEIGHBOR_COUNT + neighborCount] = neighborParticleId;
				neighborCount++;
			}
			start++;
		}
		GroupMemoryBarrierWithGroupSync();
	}
}

[numthreads(THREAD_SIZE, 1, 1)]
void CalculateDensityAndPressures(uint3 tid : SV_DispatchThreadID, uint gidx : SV_GroupIndex)
{
	uint threadId = tid.x;
	Particle particle = _particles[threadId];
	uint numTiles = 1 + _particleCount / THREAD_SIZE;
	
	int3 cellDimIndex = CalculateGridPosition(particle.position, _particleRadius);
	uint cellIndex = HashFunction(cellDimIndex, TABLE_SIZE);

	for (int tile = 0; tile < numTiles; ++tile)
	{
		uint offset = tile * THREAD_SIZE;
		_groupParticles[gidx] = _particles[offset + gidx];
		GroupMemoryBarrierWithGroupSync();
		
		for (int i = 0; i < NEIGHBOR_COUNT; i++)
		{
			uint neighborId = _neighbors[cellIndex * NEIGHBOR_COUNT + i];
			Particle neighbor = _groupParticles[neighborId];
			GroupMemoryBarrierWithGroupSync();
			
			const float3 diff = particle.position - neighbor.position;
			const float r2 = dot(diff, diff);
			const float h2 = _particleRadius * _particleRadius;
	
			if (r2 < h2)
			{
				const float rho = _mass * CalculatePoly6Kernel(r2, h2);
				_densities[threadId] += rho;
			}
		}
	}

	_densities[threadId] = max(_restDensity, _densities[threadId]);
	_pressures[threadId] = _gasConstant * (_densities[threadId] - _restDensity);
}

[numthreads(THREAD_SIZE, 1, 1)]
void CalculateForces(uint3 tid : SV_DispatchThreadID, uint gidx : SV_GroupIndex)
{
	uint threadId = tid.x;
	Particle particle = _particles[threadId];
	uint numTiles = 1 + _particleCount / THREAD_SIZE;
	
	int3 cellDimIndex = CalculateGridPosition(particle.position, _particleRadius);
	uint cellIndex = HashFunction(cellDimIndex, TABLE_SIZE);

	_forces[threadId] = float3(0, 0, 0);
	GroupMemoryBarrierWithGroupSync();

	
	for (int tile = 0; tile < numTiles; ++tile)
	{
		uint offset = tile * THREAD_SIZE;
		_groupParticles[gidx] = _particles[offset + gidx];
		GroupMemoryBarrierWithGroupSync();

		for (int i = 0; i < NEIGHBOR_COUNT; i++)
		{
			uint neighborId = _neighbors[cellIndex * NEIGHBOR_COUNT + i];
			
			Particle neighbor = _groupParticles[neighborId];
			const float3 diff = length(particle.position - neighbor.position);
			const float r2 = dot(diff, diff);
			const float r = sqrt(r2);
		
			if (r > 0.0 && r < _particleRadius)
			{
				const float3 dir = diff / r;
				const float sp = CalculateSpikyKernel(r, _particleRadius);
				const float la = CalculateLaplacianKernel(r, _particleRadius);

				_forces[threadId] -= _mass * ((_pressures[threadId] + _pressures[neighborId]) / (2 * _densities[threadId] + _densities[neighborId])) * sp * dir;
				_forces[threadId] += _viscosity * (_mass * (1.0f / _densities[neighborId]) * (_velocities[neighborId] - _velocities[threadId]) * la * dir);
			}
			GroupMemoryBarrierWithGroupSync();
		}
	}
}

[numthreads(THREAD_SIZE, 1, 1)]
void Integrate (uint3 tid : SV_DispatchThreadID)
{
	uint threadId = tid.x;
	float deltaTime = DELTA_TIME;
	float3 g = float3(0, -GRAVITY, 0);
	
	_velocities[threadId] += deltaTime * (_forces[threadId] / _densities[threadId] + g);
	_particles[threadId].position += deltaTime * _velocities[threadId];
	GroupMemoryBarrierWithGroupSync();
	
	_forces[threadId] = float3(0, 0, 0);
	GroupMemoryBarrierWithGroupSync();
	
	if (_particles[threadId].position.x < -(_boundingBox.x * 0.5) + _particleRadius)
	{
		_velocities[threadId].x *= _damping;
		_particles[threadId].position.x = -(_boundingBox.x * 0.5) + _particleRadius;
	}
	else if (_particles[threadId].position.x > (_boundingBox.x * 0.5) + _boundingBox.x)
	{
		_velocities[threadId].x *= _damping;
		_particles[threadId].position.x = (_boundingBox.x * 0.5) + _boundingBox.x;
	}
	
	if (_particles[threadId].position.y < -(_boundingBox.y * 0.5) + _particleRadius)
	{
		_velocities[threadId].y *= _damping;
		_particles[threadId].position.y = -(_boundingBox.y * 0.5) + _particleRadius;
	}
	else if (_particles[threadId].position.y > (_boundingBox.y * 0.5) + _boundingBox.y)
	{
		_velocities[threadId].y *= _damping;
		_particles[threadId].position.y = (_boundingBox.y * 0.5) + _boundingBox.y;
	}
	
	if (_particles[threadId].position.z < -(_boundingBox.z * 0.5) + _particleRadius)
	{
		_velocities[threadId].z *= _damping;
		_particles[threadId].position.z = -(_boundingBox.z * 0.5) + _particleRadius;
	}
	else if (_particles[threadId].position.z > (_boundingBox.z * 0.5) + _boundingBox.z)
	{
		_velocities[threadId].z *= _damping;
		_particles[threadId].position.z = (_boundingBox.z * 0.5) + _boundingBox.z;
	}
}