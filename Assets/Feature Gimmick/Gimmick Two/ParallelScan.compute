
#pragma kernel GlobalBlockScan
#pragma kernel AddBlockSums

#define THREAD_SIZE 256
#define NUM_BANKS 16
#define LOG_NUM_BANKS 4
#define CONFLICT_FREE_OFFSET(n) ((n) >> NUM_BANKS + (n) >> (2 * LOG_NUM_BANKS))

RWStructuredBuffer<uint> _input;
RWStructuredBuffer<uint> _output;
RWStructuredBuffer<uint> _testBuffer;
StructuredBuffer<uint> _inputElementCount;

int _bitShift;

groupshared uint _temp[THREAD_SIZE];

// https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda
[numthreads(THREAD_SIZE, 1, 1)]
void GlobalBlockScan(uint3 tid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID, uint gid : SV_GroupID)
{
	int inputElementCount = _inputElementCount[0];
	int ai = tid.x;
	int bi = tid.x + (inputElementCount / 2);
	int bankOffsetA = CONFLICT_FREE_OFFSET(ai);
	int bankOffsetB = CONFLICT_FREE_OFFSET(bi);
	
	_temp[tid.x] = 0;
	GroupMemoryBarrierWithGroupSync();
	
	_temp[ai + bankOffsetA] = _input[ai];
	_temp[bi + bankOffsetB] = _input[bi];
	GroupMemoryBarrierWithGroupSync();
	
	uint offset = 1;
	for (uint d = inputElementCount >> 1; d > 0; d >>= 1)
	{
	
		if (tid.x < d)
		{
			uint ai = offset * ((tid.x << 1) + 1) - 1;
			uint bi = offset * ((tid.x << 1) + 2) - 1;
			ai += CONFLICT_FREE_OFFSET(ai);
			bi += CONFLICT_FREE_OFFSET(bi);
			
			_temp[bi] += _temp[ai];
		}
		offset <<= 1;
		GroupMemoryBarrierWithGroupSync();
	}

	if (tid.x == 0)
	{
		_input[gid.x] = _temp[inputElementCount];
		_temp[inputElementCount - 1 + CONFLICT_FREE_OFFSET(inputElementCount - 1)] = 0;
	}
	GroupMemoryBarrierWithGroupSync();
	
	
	for (uint d = 1; d < inputElementCount; d <<= 1)
	{
		offset >>= 1;
	
		if (tid.x < d)
		{
			uint ai = offset * ((tid.x << 1) + 1) - 1;
			uint bi = offset * ((tid.x << 1) + 2) - 1;
			ai += CONFLICT_FREE_OFFSET(ai);
			bi += CONFLICT_FREE_OFFSET(bi);
	
			uint t = _temp[ai];
			_temp[ai] = _temp[bi];
			_temp[bi] += t;
		}
		GroupMemoryBarrierWithGroupSync();
	}
	
	if (tid.x < inputElementCount)
	{
		_output[tid.x] = _temp[ai + bankOffsetA];
		if (tid.x + inputElementCount < inputElementCount)
		{
			_output[tid.x + inputElementCount] = _temp[bi + bankOffsetB];
		}
	}
	GroupMemoryBarrierWithGroupSync();
	
	_output[ai] = _temp[ai + bankOffsetA];
	_output[bi] = _temp[bi + bankOffsetB];
	GroupMemoryBarrierWithGroupSync();
}

[numthreads(THREAD_SIZE, 1, 1)]
void AddBlockSums(uint3 tid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID, uint gid : SV_GroupID)
{
	int inputElementCount = _inputElementCount[0];
	
	uint blockSum = _input[gid.x];
	
	int index = 2 * gid.x * inputElementCount + tid.x;
	
	if (index < inputElementCount)
	{
		_output[index] += blockSum;
		 if (index + inputElementCount < inputElementCount)
		 {
		 	_output[index + inputElementCount] += blockSum;
		 }
	}
	GroupMemoryBarrierWithGroupSync();
}
