[Compute Shader]
SV_DispatchThreadID (uint3) 는 numthreads * Dispatch로 계산한다.
SV_GroupID (uint3) 는 dispatch로만 계산한다.
SV_GroupThreadID (uint3) 는 numthreads로만 계산한다.
SV_GroupIndex (uint) 는 numthreads.x * numthreads.y * numthreads.z - 1로 계산한다.

(1d-dispatch-ids2 사진 참조)
예를 들어 numthreads.x 가 256, Dispatch가 256일 경우
SV_DispatchThreadID.x는 0 ~ 65536 SV_GroupThreadID.x는 0 ~ 255까지의 값을 가지고 SV_GroupID.x는 0이다.
만약 DispatchThreadID가 계속 증가해서 255가 되면 GroupThreadId도 255가 되고 GroupId는 0이지만
DispatchThreadID가 256이 되면 GroupThreadId는 0이 되고 GroupId는 1이 된다.

(_ParallelSum.compute)
groupshared는 thread group 내에서 공유되는 메모리이다. 즉, 같은 GroupId 내에서만 공유된다.
ParallelSum 에 Thread_Size가 256이고 _buffer[gtid.x] = _numbers[tid.x]; 가 있는데
이는 256개의 thread가 각 스레드가 동시에 _numbers[tid.x] 값을 읽어와서 _buffer[gtid.x]에 저장한다.
마찬가지로 for문에서 stride가 128이고 if (gtid.x < stride) 이면 128번 쓰레드까지 _buffer[gtid.x] += _buffer[gtid.x + stride]; 를 실행한다.

GroupMemoryBarrierWithGroupSync는 그룹 내 모든 스레드가 이전 코드들을 완료할 때까지 기다린다.

[이웃 검색]
n = 5 // cell index
for(int i = n - 1; i < n + 1; i++)
for(int j = n - 1; j < n + 1; j++)
for(int k = n - 1; k < n + 1; k++)
{
	int cell = arr[i][j][k];
}

(ParallelCountingSort.compute)
28 39 10 2 48 49
Counting Sort는 첫번쨰 자리 숫자의 최댓값인 k + 1의 배열이 필요
그러면 index가 0 ~ 9까지인 배열이 생기는데
각 index에 맞는 숫자의 개수를 세서 넣어주면 
1번째 자리
Count[1, 0, 1, 0, 0, 0, 0, 0, 2, 2]

Inclusive Prefix Sum
Count[1, 1, 2, 2, 2, 2, 2, 2, 4, 6]

Count[8] = 4
Sorted[4 - 1] = 28
Count[1, 1, 2, 2, 2, 2, 2, 2, 3, 6]

Count[9] = 6
Sorted[6 - 1] = 39
Count[1, 1, 2, 2, 2, 2, 2, 2, 3, 5]

Count[0] = 1
Sorted[1 - 1] = 10
Count[0, 1, 2, 2, 2, 2, 2, 2, 3, 5]

Count[2] = 2
Sorted[2 - 1] = 2
Count[0, 1, 1, 2, 2, 2, 2, 2, 3, 5]

Count[8] = 3
Sorted[3 - 1] = 48
Count[0, 1, 1, 2, 2, 2, 2, 2, 2, 5]

Count[9] = 5
Sorted[5 - 1] = 49
Count[0, 1, 1, 2, 2, 2, 2, 2, 2, 4]

sorted index 0, 1, 2, 3, 4, 5
sorted value 10, 2, 28, 48, 39, 49



Exclusive Prefix Sum
Count[0, 1, 1, 2, 2, 2, 2, 2, 2, 4]

Count[8] = 2
Sorted[2] = 28
Count[0, 1, 1, 2, 2, 2, 2, 2, 3, 4]

Count[9] = 4
Sorted[4] = 39
Count[0, 1, 1, 2, 2, 2, 2, 2, 3, 5]

Count[0] = 0
Sorted[0] = 10
Count[1, 1, 1, 2, 2, 2, 2, 2, 3, 5]

Count[2] = 1
Sorted[1] = 2
Count[1, 1, 2, 2, 2, 2, 2, 2, 3, 5]

Count[8] = 3
Sorted[3] = 48
Count[1, 1, 2, 2, 2, 2, 2, 2, 4, 5]

Count[9] = 5
Sorted[5] = 49
Count[1, 1, 2, 2, 2, 2, 2, 2, 4, 6]

sorted index 0, 1, 2, 3, 4, 5
sorted value 10, 2, 28, 48, 39, 49

2번째 자리
Count[1, 1, 1, 1, 2, 0, 0, 0, 0, 0]

Exclusive Prefix Sum
Count[0, 1, 2, 3, 4, 6, 6, 6, 6, 6]

Count[1] = 1
Sorted[1] = 10
Count[0, 2, 2, 3, 4, 6, 6, 6, 6, 6]

Count[0] = 0
Sorted[0] = 2
Count[1, 2, 2, 3, 4, 6, 6, 6, 6, 6]

Count[2] = 2
Sorted[2] = 28
Count[1, 2, 3, 3, 4, 6, 6, 6, 6, 6]

Count[4] = 4
Sorted[4] = 48
Count[1, 2, 3, 3, 5, 6, 6, 6, 6, 6]

Count[3] = 3
Sorted[3] = 39
Count[1, 2, 3, 4, 5, 6, 6, 6, 6, 6]

Count[4] = 5
Sorted[5] = 49
Count[1, 2, 3, 4, 6, 6, 6, 6, 6, 6]

sorted index 0, 1, 2, 3, 4, 5
sorted value 2, 10, 28, 39, 48, 49

unroll은 반복 횟수가 크지 않고 횟수가 정해져 있으면 쓰기 좋다.

interlockedAdd는 다른 스레드가 접근하지 못하게 하는 동시에 더하기 연산을 하는 함수이다.
uint sortedIndex;

InterlockedAdd(_countingBuffer[digitValue], 1, sortedIndex); 로 예시를 들어보면 
첫 번째 매개변수인 _countingBuffer[digitValue]에 두 번째 매개변수인 1을 더함
그리고 세 번째 매개변수인 sortedIndex에 더하기 전의 값, 즉 원래 _countingBuffer[digitValue]의 값을 저장한다.

